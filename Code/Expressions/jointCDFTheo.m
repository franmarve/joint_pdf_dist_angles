% *************************************************************************
% MAIN AUTHOR: Francisco J. Martin-Vega Francisco J. Martin-Vega
% *************************************************************************
% GROUP: Lab 1.3.5., Communications and Signal Processing Lab (ComSP), 
% Telecommunication Research Institute (TELMA), ETSIT, University of Malaga
% *************************************************************************
% DESCRIPTION:
% It obtains the joint CDF of distance and angle between a reference point
% and a set of randomly placed points with uniform distribution. 
% *************************************************************************

function outVct = jointCDFTheo(r, theta, Lx, Ly, u)

hxp = Lx/2 - u(1);  % Latex notation: h_x^{+}
hxm = -Lx/2 - u(1); % Latex notation: h_x^{-}
if hxm == 0, hxm = -0; end
hyp = Ly/2 - u(2);  % Latex notation: h_y^{+}
hym = -Ly/2 - u(2); % Latex notation: h_y^{-}
if hym == 0, hym = -0; end

% Function handle for inverse tan(x), 1/tan(x)
itan = @(x) 1./tan(x);

I_xp = double(r >= hxp).*(  hxp^2/2.*( tan(min(theta, min(atan(hyp/hxp),...
    acos(hxp./r)))) + F(@tan, max(atan(hym/hxp) +2*pi, ...
    2*pi - acos(hxp./r)), theta) )  ...
    + r.^2/2.*( pp(min(theta, atan(hyp/hxp)) -acos(hxp./r)) ...
    + pp(min(theta, 2*pi - acos(hxp./r)) -2*pi -atan(hym/hxp)) ) ) ...
    ...
    + r.^2/2.*double(r < hxp).*( pp(min(theta, atan(hyp/hxp))) ...
    + pp(theta -2*pi -atan(hym/hxp)) );

I_xm = double(r >= -hxm).*(  hxm^2/2.*( F(@tan, pi, min(theta, ...
    min(atan(hym/hxm) + pi, 2*pi -acos(hxm./r)))) ...
    + F(@tan, max(atan(hyp/hxm) + pi, acos(hxm./r)), min(theta, pi)) ) ...
    + r.^2/2.*( pp(min(theta, atan(hym/hxm) +pi) -2*pi +acos(hxm./r)) ...
    + pp(min(theta, acos(hxm./r)) -atan(hyp/hxm) -pi) )) ...
    ...
    + r.^2/2.*double(r < -hxm).*( pp(min(theta, atan(hym/hxm) +pi) -pi) ...
    + pp(min(theta, pi) -atan(hyp/hxm) -pi) );

I_yp = double(r >= hyp).*(  -hyp^2/2.*( ...
    F(itan, max(atan(hyp/hxp), asin(hyp./r)), min(theta, pi/2)) ...
    + F(itan, pi/2, min(theta, min(atan(hyp/hxm) +pi, pi-asin(hyp./r)))) ) ...
    + r.^2/2.*( pp(min(theta, asin(hyp./r)) -atan(hyp/hxp)) ...
    + pp(min(theta, atan(hyp/hxm) + pi) -pi +asin(hyp./r)) ) ) ...
    ...
    + r.^2/2.*double(r < hyp).*( pp(min(theta, pi/2) -atan(hyp/hxp)) ...
    + pp(min(theta, atan(hyp/hxm) +pi) -pi/2) ); 

Iym = double(r >= -hym).*(  -hym^2/2.*( F(itan,max(atan(hym/hxm) +pi, ...
    pi -asin(hym./r)), min(theta, 3*pi/2)) ...
    + F(itan,3*pi/2,min(theta, min(atan(hym/hxp) +2*pi, ...
    2*pi +asin(hym./r)))) ) ...
    +r.^2/2.*( pp(min(theta, pi -asin(hym./r)) -pi -atan(hym/hxm)) ...
    + pp(min(theta, atan(hym/hxp) +2*pi) -2*pi -asin(hym./r)) )  )...
    ...
    ...
    + r.^2/2.*double(r < -hym).*( pp(min(theta, 3*pi/2) ...
    -atan(hym/hxm) -pi) ...
    + pp(min(theta, 2*pi +atan(hym/hxp)) -3*pi/2) ); 

outVct = 1/(Lx*Ly)*(I_xp + I_xm + I_yp + Iym);
